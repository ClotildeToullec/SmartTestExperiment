"
Abstract class to run smartTest experiments. It factorises the code to find and run the tests for a given change

It contains:
- the change to test
- instance variables to hold the tests to run
- instance variables to perform static/dynamic analyses
- logger and instance variables to store the results

"
Class {
	#name : #AbstractStaticDynamicExperiment,
	#superclass : #Object,
	#instVars : [
		'currentChange',
		'collectionOfTestSuites',
		'logger',
		'dataSet',
		'smTResults',
		'smTFinders',
		'packages'
	],
	#classInstVars : [
		'includeStaticAnalysis',
		'includeDynamicAnalysis'
	],
	#category : #'SmartTestExperiment-analysis'
}

{ #category : #accessing }
AbstractStaticDynamicExperiment class >> includeDynamicAnalysis [
	"self includeDynamicAnalysis"

	<script>
	includeDynamicAnalysis isNil
		ifTrue: [ includeDynamicAnalysis := true ].
	^ includeDynamicAnalysis
]

{ #category : #accessing }
AbstractStaticDynamicExperiment class >> includeDynamicAnalysis: aBoolean [

self flag: 'Generated by Eleonore: Remove use of xxDynamic and use a Set instead'.
	"self includeDynamicAnalysis: true"

	"self includeDynamicAnalysis: false"
	
	"self includeDynamicAnalysis"

	self assert: (aBoolean isKindOf: Boolean).
	includeDynamicAnalysis := aBoolean
]

{ #category : #accessing }
AbstractStaticDynamicExperiment class >> includeStaticAnalysis [
	"self includeStaticAnalysis"

	<script>
	self flag: 'Generated by Eleonore: Remove use of xxStatic and use a Set instead and a generic method'.
	includeStaticAnalysis isNil
		ifTrue: [ includeStaticAnalysis := true ].
	^ includeStaticAnalysis
]

{ #category : #accessing }
AbstractStaticDynamicExperiment class >> includeStaticAnalysis: aBoolean [
	"self includeStaticAnalysis: true"

	"self includeStaticAnalysis: false"

	"self includeStaticAnalysis: 0"

	"self includeStaticAnalysis"
self flag: 'Generated by Eleonore: Remove use of xxStatic and use a Set instead and a generic method'.
	self assert: (aBoolean isKindOf: Boolean).
	includeStaticAnalysis := aBoolean
]

{ #category : #utilities }
AbstractStaticDynamicExperiment class >> methodRefAsTestCase: aMethodReference [
	"self methodRefAsTestCase: #'TestNetwork>>testHTMLPrint'"

	"self methodRefAsTestCase: #'TestNetwork class>>testHTMLPrint'"

	"self methodRefAsTestCase: #'Unexisting>>testHTMLPrint'"

	| splitted testClass testSelector |
	splitted := aMethodReference splitOn: '>>'.
	splitted size ~= 2
		ifTrue: [ ^ nil ].
	testClass := Smalltalk classNamed: (splitted at: 1) asSymbol.
	testClass isNil
		ifTrue: [ ^ nil ].
	testClass isTestCase
		ifFalse: [ ^ nil ].
	testSelector := (splitted at: 2) asSymbol.
	^ testClass selector: testSelector
]

{ #category : #running }
AbstractStaticDynamicExperiment class >> ombuEntriesFromFile: ombFile [
	^ (EpLog freshFromFile: ombFile) entries
]

{ #category : #private }
AbstractStaticDynamicExperiment >> changeMustBePerformedAfterAnalysis [
	^ currentChange content class = EpMethodRemoval
]

{ #category : #accessing }
AbstractStaticDynamicExperiment >> changeNumber [
	^ (currentChange tagAt: #self) localName
]

{ #category : #private }
AbstractStaticDynamicExperiment >> createTestSuite: aCollectionOfMethodReferences [
	| reducedTestSuite aCollectionOfTestCases |
	reducedTestSuite := TestSuite named: 'Test Suite from Method names'.
	aCollectionOfTestCases := aCollectionOfMethodReferences
		collect: [ :aMethodReference | self class methodRefAsTestCase: aMethodReference ].
	aCollectionOfTestCases := aCollectionOfTestCases select: [ :tc | tc notNil ].
	^ reducedTestSuite addTests: aCollectionOfTestCases
]

{ #category : #'actions-public' }
AbstractStaticDynamicExperiment >> createTestcases [
	| testCaseClasses |
	testCaseClasses := self packages flatCollect: [ :each | 
		(each asPackageIfAbsent: [ nil ])
			ifNotNil: [ :package | package classes select: #isTestCase ]
			ifNil: [ #() ]
	].
	collectionOfTestSuites := testCaseClasses collect: #buildSuite.

	logger logCreatedTestcases: testCaseClasses
]

{ #category : #accessing }
AbstractStaticDynamicExperiment >> currentChange [
	^ currentChange
]

{ #category : #initialization }
AbstractStaticDynamicExperiment >> initialize [
	super initialize.

	"Dicionary with all SmtFinders."
	smTFinders := Dictionary new.
	smTResults := Dictionary new.

	"Not generic methods."
	self initializeStaticFinder.
	self initializeDynamicFinder.

	"Coherent with ExperimentLauncher but not with TimeAndMem"
	smTResults at: #static put: IdentityDictionary new.
	smTResults at: #dynamic put: IdentityDictionary new.
	currentChange := nil.
	logger := ExperimentLauncherLogger new
]

{ #category : #initialization }
AbstractStaticDynamicExperiment >> initializeDynamicFinder [
	self
		initializeSmartFinder: #dynamic
		filter: SmTDefaultClassPackagesFilter new
		cacheStrategy: SmTBasicCacheStrategy new
		finder: SmTTestCoverageTestFinderStrategy new
]

{ #category : #initialization }
AbstractStaticDynamicExperiment >> initializeSmartFinder: aSymbol filter: aSmTFilterStrategy cacheStrategy: aSmTCacheStrategy finder: aSmTTestFinderStrategy [
	smTFinders
		at: aSymbol
		put:
			(SmartFinder new
				filter: aSmTFilterStrategy;
				cacheStrategy: aSmTCacheStrategy;
				smtFinder: aSmTTestFinderStrategy)
]

{ #category : #initialization }
AbstractStaticDynamicExperiment >> initializeStaticFinder [
	self
		initializeSmartFinder: #static
		filter: SmTDefaultClassPackagesFilter new
		cacheStrategy: SmTNoCacheStrategy new
		finder: SmTSenderTestFinderStrategy new
]

{ #category : #private }
AbstractStaticDynamicExperiment >> isSystemWideMethod: epChange [
	| chgClass |
	(#(#new #initialize) includes: epChange methodAffected selector)
		ifTrue: [ ^ true ].

	"not a Collection method either ..."
	chgClass := epChange methodAffected methodClass.
	chgClass ifNil: [ ^ false ].	"sometimes the change creates a method for an unexisting class ..."
	chgClass isTrait
		ifTrue: [ ^ false ].	"not Traits in collections and would polluate following code"
	epChange methodAffected isMetaSide
		ifTrue: [ chgClass := chgClass instanceSide ].
	^ chgClass inheritsFrom: Collection
]

{ #category : #accessing }
AbstractStaticDynamicExperiment >> logFileReference: logfileRef [
	logger logFileReference: logfileRef
]

{ #category : #running }
AbstractStaticDynamicExperiment >> manageBuildCache [
	| ts |
	self createTestcases.
	ts := TestSuite new.
	ts addTests: collectionOfTestSuites.
	smTFinders
		valuesDo: [ :finder | 
			finder resetCache.
			finder buildCacheFromTestSuite: ts ]
]

{ #category : #private }
AbstractStaticDynamicExperiment >> ombuEntriesFromFile: ombFile [
	"conveniance method to call the class side one"
	^ self class ombuEntriesFromFile: ombFile
]

{ #category : #accessing }
AbstractStaticDynamicExperiment >> packages [
	^ dataSet packages
]

{ #category : #private }
AbstractStaticDynamicExperiment >> packages: aCollectionOfCategoryNames [
	self flag: 'shouldNotImplement anymore, implementation change to an object describing the ApplicationDataSet'.

	aCollectionOfCategoryNames assert: aCollectionOfCategoryNames isSequenceable description: 'Expected a collection for #packages:'.
	packages := aCollectionOfCategoryNames.
]

{ #category : #running }
AbstractStaticDynamicExperiment >> performAnalyses [
	smTFinders keysDo: [ :key | self performAnalysis: key ]
]

{ #category : #running }
AbstractStaticDynamicExperiment >> performAnalysis: aSymbol [
	^ ((smTFinders at: aSymbol)
		researchTestsForMethod: currentChange content methodAffected compiledMethod)
		collect: [ :method | method fullName ]
]

{ #category : #private }
AbstractStaticDynamicExperiment >> processChange [
	currentChange content isCodeChange
		ifTrue: [
			logger logAppliedCodeChange: currentChange content.
			currentChange content applyCodeChange ]
		ifFalse: [ logger logIgnoreCodeChange ].


]

{ #category : #private }
AbstractStaticDynamicExperiment >> runSuites [
	collectionOfTestSuites do: [ :each | each run ]
]

{ #category : #private }
AbstractStaticDynamicExperiment >> smarttestInterventionNeeded: aChange [
	"Answer whether currentChange corresponds to a change which requires a Smarttest intervention
	 and this is when:
	 - the change is on a method
	 - but it does not _introduce_ (so not a methodRemoval) a self halt
	 - the change is not on a widely spread Pharo method (ex: #initialize) because it would end up looking for all methods in the image
		"
	| epChange |
	epChange := aChange content.
	(epChange isEpMethodChange)
		ifFalse: [ ^ false ].

	(epChange class = EpMethodRemoval)
		ifTrue: [  ^ (self isSystemWideMethod: epChange) not ].

	(epChange newSourceCode includesSubstring: 'self halt')
		ifTrue: [ ^ false ].

	^ (self isSystemWideMethod: epChange) not
]
