"
See comment for TimeAndMemoryExperiment for an overview of the whole process.

Here, we are running in a special image tailored for one experiment. It runs the experiment and output the results in a CSV file then quit
"
Class {
	#name : #TimeAndMemorySlave,
	#superclass : #TimeAndMemoryExperiment,
	#instVars : [
		'expNumber'
	],
	#classInstVars : [
		'runningExperiment'
	],
	#category : #'SmartTestExperiment-timeAndMem'
}

{ #category : #accessing }
TimeAndMemorySlave class >> getInstance [
	^runningExperiment ifNil: [ runningExperiment := self new ]
]

{ #category : #analyses }
TimeAndMemorySlave >> applyChangeAndRunAnalyses [
	"compute all tests and selected tests for change"

	self manageBuildCache.
	self flag: 'Nicolas: not sure why we perform analyses here ?1?!?'.
	self changeMustBePerformedAfterAnalysis
		ifTrue: [ "method removal"
			self performAnalyses.
			self processChange ]
		ifFalse: [ "method addition or modification"
			self processChange.
			self performAnalyses ]
]

{ #category : #'experiment-preparation' }
TimeAndMemorySlave >> changeImageNameAndQuit [
	(Smalltalk saveAs: self runningImageBaseName)
		ifFalse: [
			Author fullName: 'TimeAndMemoryExperimenter'.
			self signalEndOfProcess: self prepareSignal.
			Smalltalk snapshot: false andQuit: true
		]
]

{ #category : #'ombu changes' }
TimeAndMemorySlave >> loadChangesBefore: aChangeNumber [
	| remaining |
	remaining := aChangeNumber.
	dataSet ombuFiles
		do: [ :ombName | 
			| ombFile |
			ombFile := dataSet directoryReference / 'ombu-sessions' / ombName.
			(self ombuEntriesFromFile: ombFile)
				do: [ :ombEntry | 
					(remaining := remaining - 1) > 0
						ifTrue: [ ombEntry content isCodeChange
								ifTrue: [ ombEntry content applyCodeChange ] ]
						ifFalse: [ ^ true ] ] ].
	^ false
]

{ #category : #'tests stats' }
TimeAndMemorySlave >> numberOfTests: aCollectionOfTestSuites [
	^ (aCollectionOfTestSuites flatCollect: #flatCollectTests) size
]

{ #category : #analyses }
TimeAndMemorySlave >> performAnalysis: aSymbol [
	"Clotilde : To be coherent with previous implementation, no IdentityDictionary containing results for every change but just the results for 1 change"

	smTResults at: aSymbol put: (super performAnalysis: aSymbol)
]

{ #category : #'experiment-preparation' }
TimeAndMemorySlave >> prepareForChange: aChangeNumber myDatasetName: datasetName [
	"we are in an image specific to the data set chosen, so we should not need the datasetName
	 but it is easier to recover it from the command line parameters than to prepare each of the
	 data sets specific images individually"

	self recoverChange: aChangeNumber inDataset: datasetName.
	self resetRunningImage.

	"self prepareSmartFinders. This method has been removed and smartFinders prepared at initiliazation"
	self loadChangesBefore: aChangeNumber.
	self applyChangeAndRunAnalyses.

	self changeImageNameAndQuit
]

{ #category : #'experiment-running' }
TimeAndMemorySlave >> quitImage [
	self signalEndOfProcess: (self runningExpSignal: expNumber).
	
	Smalltalk snapshot: false andQuit: true
]

{ #category : #'experiment-preparation' }
TimeAndMemorySlave >> recoverChange: aChangeNumber inDataset: datasetName [
	dataSet := ApplicationDataSet perform: datasetName.	"recover my dataset informations"
	self packages: dataSet packages.
	currentChange := dataSet changeAtPos: aChangeNumber
]

{ #category : #'experiment-running' }
TimeAndMemorySlave >> reportAllTime: allTestsTime staticTime: staticTestsTime dynamicTime: dynamicTestsTime [
	"see CSV header line in TimeAndMemoryExperiment>>eraseCSV:"

	self
		flag:
			'Generated by Eleonore: Here we should have an iteration on smartTest Results'.
	self
		saveCSVLine:
			{dataSet name.
			self changeNumber.
			currentChange content methodAffected fullName asString.
			(self numberOfTests: collectionOfTestSuites).
			allTestsTime.
			(smTResults at: #static) size.
			staticTestsTime.
			(smTResults at: #dynamic) size.
			dynamicTestsTime}
]

{ #category : #'experiment-preparation' }
TimeAndMemorySlave >> resetRunningImage [
	self runningImageName asFileReference deleteIfAbsent: [ "nothing" ]
]

{ #category : #'experiment-running' }
TimeAndMemorySlave >> runExperiment: anInt [
	| allTestsTime staticTestsTime dynamicTestsTime |
	expNumber := anInt.

	allTestsTime := self timeForTestSuites.
	staticTestsTime := self timeForTests: (smTResults at: #static).
	dynamicTestsTime := self timeForTests: (smTResults at: #dynamic).

	self
		reportAllTime: allTestsTime
		staticTime: staticTestsTime
		dynamicTime: dynamicTestsTime.
	
	self quitImage
]

{ #category : #processes }
TimeAndMemorySlave >> signalEndOfProcess [
	self signalEndOfProcess: (self runningExpSignal: expNumber)
]

{ #category : #'tests stats' }
TimeAndMemorySlave >> timeForTestSuites [
	^ [ self runSuites ] timeToRunInMicroSeconds
]

{ #category : #'tests stats' }
TimeAndMemorySlave >> timeForTests: testCollection [
	| suite |
	suite := self createTestSuite: testCollection.
	^ [ suite run] timeToRunInMicroSeconds
]
